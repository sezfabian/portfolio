{"version":3,"file":"BufferGeometryUtils-DMXTjlvX.js","names":[],"sources":["../../three-stdlib/utils/BufferGeometryUtils.js"],"sourcesContent":["import { BufferGeometry, BufferAttribute, InterleavedBuffer, InterleavedBufferAttribute, TrianglesDrawMode, TriangleFanDrawMode, TriangleStripDrawMode, Vector3, Float32BufferAttribute } from \"three\";\nimport { getWithKey } from \"../types/helpers.js\";\nconst mergeBufferGeometries = (geometries, useGroups) => {\n  const isIndexed = geometries[0].index !== null;\n  const attributesUsed = new Set(Object.keys(geometries[0].attributes));\n  const morphAttributesUsed = new Set(Object.keys(geometries[0].morphAttributes));\n  const attributes = {};\n  const morphAttributes = {};\n  const morphTargetsRelative = geometries[0].morphTargetsRelative;\n  const mergedGeometry = new BufferGeometry();\n  let offset = 0;\n  geometries.forEach((geom, i) => {\n    let attributesCount = 0;\n    if (isIndexed !== (geom.index !== null)) {\n      console.error(\n        \"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index \" + i + \". All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them.\"\n      );\n      return null;\n    }\n    for (let name in geom.attributes) {\n      if (!attributesUsed.has(name)) {\n        console.error(\n          \"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index \" + i + '. All geometries must have compatible attributes; make sure \"' + name + '\" attribute exists among all geometries, or in none of them.'\n        );\n        return null;\n      }\n      if (attributes[name] === void 0) {\n        attributes[name] = [];\n      }\n      attributes[name].push(geom.attributes[name]);\n      attributesCount++;\n    }\n    if (attributesCount !== attributesUsed.size) {\n      console.error(\n        \"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index \" + i + \". Make sure all geometries have the same number of attributes.\"\n      );\n      return null;\n    }\n    if (morphTargetsRelative !== geom.morphTargetsRelative) {\n      console.error(\n        \"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index \" + i + \". .morphTargetsRelative must be consistent throughout all geometries.\"\n      );\n      return null;\n    }\n    for (let name in geom.morphAttributes) {\n      if (!morphAttributesUsed.has(name)) {\n        console.error(\n          \"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index \" + i + \".  .morphAttributes must be consistent throughout all geometries.\"\n        );\n        return null;\n      }\n      if (morphAttributes[name] === void 0)\n        morphAttributes[name] = [];\n      morphAttributes[name].push(geom.morphAttributes[name]);\n    }\n    mergedGeometry.userData.mergedUserData = mergedGeometry.userData.mergedUserData || [];\n    mergedGeometry.userData.mergedUserData.push(geom.userData);\n    if (useGroups) {\n      let count;\n      if (geom.index) {\n        count = geom.index.count;\n      } else if (geom.attributes.position !== void 0) {\n        count = geom.attributes.position.count;\n      } else {\n        console.error(\n          \"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index \" + i + \". The geometry must have either an index or a position attribute\"\n        );\n        return null;\n      }\n      mergedGeometry.addGroup(offset, count, i);\n      offset += count;\n    }\n  });\n  if (isIndexed) {\n    let indexOffset = 0;\n    const mergedIndex = [];\n    geometries.forEach((geom) => {\n      const index = geom.index;\n      for (let j = 0; j < index.count; ++j) {\n        mergedIndex.push(index.getX(j) + indexOffset);\n      }\n      indexOffset += geom.attributes.position.count;\n    });\n    mergedGeometry.setIndex(mergedIndex);\n  }\n  for (let name in attributes) {\n    const mergedAttribute = mergeBufferAttributes(attributes[name]);\n    if (!mergedAttribute) {\n      console.error(\n        \"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the \" + name + \" attribute.\"\n      );\n      return null;\n    }\n    mergedGeometry.setAttribute(name, mergedAttribute);\n  }\n  for (let name in morphAttributes) {\n    const numMorphTargets = morphAttributes[name][0].length;\n    if (numMorphTargets === 0)\n      break;\n    mergedGeometry.morphAttributes = mergedGeometry.morphAttributes || {};\n    mergedGeometry.morphAttributes[name] = [];\n    for (let i = 0; i < numMorphTargets; ++i) {\n      const morphAttributesToMerge = [];\n      for (let j = 0; j < morphAttributes[name].length; ++j) {\n        morphAttributesToMerge.push(morphAttributes[name][j][i]);\n      }\n      const mergedMorphAttribute = mergeBufferAttributes(morphAttributesToMerge);\n      if (!mergedMorphAttribute) {\n        console.error(\n          \"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the \" + name + \" morphAttribute.\"\n        );\n        return null;\n      }\n      mergedGeometry.morphAttributes[name].push(mergedMorphAttribute);\n    }\n  }\n  return mergedGeometry;\n};\nconst mergeBufferAttributes = (attributes) => {\n  let TypedArray = void 0;\n  let itemSize = void 0;\n  let normalized = void 0;\n  let arrayLength = 0;\n  attributes.forEach((attr) => {\n    if (TypedArray === void 0) {\n      TypedArray = attr.array.constructor;\n    }\n    if (TypedArray !== attr.array.constructor) {\n      console.error(\n        \"THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes.\"\n      );\n      return null;\n    }\n    if (itemSize === void 0)\n      itemSize = attr.itemSize;\n    if (itemSize !== attr.itemSize) {\n      console.error(\n        \"THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes.\"\n      );\n      return null;\n    }\n    if (normalized === void 0)\n      normalized = attr.normalized;\n    if (normalized !== attr.normalized) {\n      console.error(\n        \"THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes.\"\n      );\n      return null;\n    }\n    arrayLength += attr.array.length;\n  });\n  if (TypedArray && itemSize) {\n    const array = new TypedArray(arrayLength);\n    let offset = 0;\n    attributes.forEach((attr) => {\n      array.set(attr.array, offset);\n      offset += attr.array.length;\n    });\n    return new BufferAttribute(array, itemSize, normalized);\n  }\n};\nconst interleaveAttributes = (attributes) => {\n  let TypedArray = void 0;\n  let arrayLength = 0;\n  let stride = 0;\n  for (let i = 0, l = attributes.length; i < l; ++i) {\n    const attribute = attributes[i];\n    if (TypedArray === void 0)\n      TypedArray = attribute.array.constructor;\n    if (TypedArray !== attribute.array.constructor) {\n      console.error(\"AttributeBuffers of different types cannot be interleaved\");\n      return null;\n    }\n    arrayLength += attribute.array.length;\n    stride += attribute.itemSize;\n  }\n  const interleavedBuffer = new InterleavedBuffer(new TypedArray(arrayLength), stride);\n  let offset = 0;\n  const res = [];\n  const getters = [\"getX\", \"getY\", \"getZ\", \"getW\"];\n  const setters = [\"setX\", \"setY\", \"setZ\", \"setW\"];\n  for (let j = 0, l = attributes.length; j < l; j++) {\n    const attribute = attributes[j];\n    const itemSize = attribute.itemSize;\n    const count = attribute.count;\n    const iba = new InterleavedBufferAttribute(interleavedBuffer, itemSize, offset, attribute.normalized);\n    res.push(iba);\n    offset += itemSize;\n    for (let c = 0; c < count; c++) {\n      for (let k = 0; k < itemSize; k++) {\n        const set = getWithKey(iba, setters[k]);\n        const get = getWithKey(attribute, getters[k]);\n        set(c, get(c));\n      }\n    }\n  }\n  return res;\n};\nfunction estimateBytesUsed(geometry) {\n  let mem = 0;\n  for (let name in geometry.attributes) {\n    const attr = geometry.getAttribute(name);\n    mem += attr.count * attr.itemSize * attr.array.BYTES_PER_ELEMENT;\n  }\n  const indices = geometry.getIndex();\n  mem += indices ? indices.count * indices.itemSize * indices.array.BYTES_PER_ELEMENT : 0;\n  return mem;\n}\nfunction mergeVertices(geometry, tolerance = 1e-4) {\n  tolerance = Math.max(tolerance, Number.EPSILON);\n  const hashToIndex = {};\n  const indices = geometry.getIndex();\n  const positions = geometry.getAttribute(\"position\");\n  const vertexCount = indices ? indices.count : positions.count;\n  let nextIndex = 0;\n  const attributeNames = Object.keys(geometry.attributes);\n  const attrArrays = {};\n  const morphAttrsArrays = {};\n  const newIndices = [];\n  const getters = [\"getX\", \"getY\", \"getZ\", \"getW\"];\n  for (let i = 0, l = attributeNames.length; i < l; i++) {\n    const name = attributeNames[i];\n    attrArrays[name] = [];\n    const morphAttr = geometry.morphAttributes[name];\n    if (morphAttr) {\n      morphAttrsArrays[name] = new Array(morphAttr.length).fill(0).map(() => []);\n    }\n  }\n  const decimalShift = Math.log10(1 / tolerance);\n  const shiftMultiplier = Math.pow(10, decimalShift);\n  for (let i = 0; i < vertexCount; i++) {\n    const index = indices ? indices.getX(i) : i;\n    let hash = \"\";\n    for (let j = 0, l = attributeNames.length; j < l; j++) {\n      const name = attributeNames[j];\n      const attribute = geometry.getAttribute(name);\n      const itemSize = attribute.itemSize;\n      for (let k = 0; k < itemSize; k++) {\n        hash += `${~~(attribute[getters[k]](index) * shiftMultiplier)},`;\n      }\n    }\n    if (hash in hashToIndex) {\n      newIndices.push(hashToIndex[hash]);\n    } else {\n      for (let j = 0, l = attributeNames.length; j < l; j++) {\n        const name = attributeNames[j];\n        const attribute = geometry.getAttribute(name);\n        const morphAttr = geometry.morphAttributes[name];\n        const itemSize = attribute.itemSize;\n        const newarray = attrArrays[name];\n        const newMorphArrays = morphAttrsArrays[name];\n        for (let k = 0; k < itemSize; k++) {\n          const getterFunc = getters[k];\n          newarray.push(attribute[getterFunc](index));\n          if (morphAttr) {\n            for (let m = 0, ml = morphAttr.length; m < ml; m++) {\n              newMorphArrays[m].push(morphAttr[m][getterFunc](index));\n            }\n          }\n        }\n      }\n      hashToIndex[hash] = nextIndex;\n      newIndices.push(nextIndex);\n      nextIndex++;\n    }\n  }\n  const result = geometry.clone();\n  for (let i = 0, l = attributeNames.length; i < l; i++) {\n    const name = attributeNames[i];\n    const oldAttribute = geometry.getAttribute(name);\n    const buffer = new oldAttribute.array.constructor(attrArrays[name]);\n    const attribute = new BufferAttribute(buffer, oldAttribute.itemSize, oldAttribute.normalized);\n    result.setAttribute(name, attribute);\n    if (name in morphAttrsArrays) {\n      for (let j = 0; j < morphAttrsArrays[name].length; j++) {\n        const oldMorphAttribute = geometry.morphAttributes[name][j];\n        const buffer2 = new oldMorphAttribute.array.constructor(morphAttrsArrays[name][j]);\n        const morphAttribute = new BufferAttribute(buffer2, oldMorphAttribute.itemSize, oldMorphAttribute.normalized);\n        result.morphAttributes[name][j] = morphAttribute;\n      }\n    }\n  }\n  result.setIndex(newIndices);\n  return result;\n}\nfunction toTrianglesDrawMode(geometry, drawMode) {\n  if (drawMode === TrianglesDrawMode) {\n    console.warn(\"THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles.\");\n    return geometry;\n  }\n  if (drawMode === TriangleFanDrawMode || drawMode === TriangleStripDrawMode) {\n    let index = geometry.getIndex();\n    if (index === null) {\n      const indices = [];\n      const position = geometry.getAttribute(\"position\");\n      if (position !== void 0) {\n        for (let i = 0; i < position.count; i++) {\n          indices.push(i);\n        }\n        geometry.setIndex(indices);\n        index = geometry.getIndex();\n      } else {\n        console.error(\n          \"THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.\"\n        );\n        return geometry;\n      }\n    }\n    const numberOfTriangles = index.count - 2;\n    const newIndices = [];\n    if (index) {\n      if (drawMode === TriangleFanDrawMode) {\n        for (let i = 1; i <= numberOfTriangles; i++) {\n          newIndices.push(index.getX(0));\n          newIndices.push(index.getX(i));\n          newIndices.push(index.getX(i + 1));\n        }\n      } else {\n        for (let i = 0; i < numberOfTriangles; i++) {\n          if (i % 2 === 0) {\n            newIndices.push(index.getX(i));\n            newIndices.push(index.getX(i + 1));\n            newIndices.push(index.getX(i + 2));\n          } else {\n            newIndices.push(index.getX(i + 2));\n            newIndices.push(index.getX(i + 1));\n            newIndices.push(index.getX(i));\n          }\n        }\n      }\n    }\n    if (newIndices.length / 3 !== numberOfTriangles) {\n      console.error(\"THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.\");\n    }\n    const newGeometry = geometry.clone();\n    newGeometry.setIndex(newIndices);\n    newGeometry.clearGroups();\n    return newGeometry;\n  } else {\n    console.error(\"THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:\", drawMode);\n    return geometry;\n  }\n}\nfunction computeMorphedAttributes(object) {\n  if (object.geometry.isBufferGeometry !== true) {\n    console.error(\"THREE.BufferGeometryUtils: Geometry is not of type BufferGeometry.\");\n    return null;\n  }\n  const _vA = new Vector3();\n  const _vB = new Vector3();\n  const _vC = new Vector3();\n  const _tempA = new Vector3();\n  const _tempB = new Vector3();\n  const _tempC = new Vector3();\n  const _morphA = new Vector3();\n  const _morphB = new Vector3();\n  const _morphC = new Vector3();\n  function _calculateMorphedAttributeData(object2, material2, attribute, morphAttribute, morphTargetsRelative2, a2, b2, c2, modifiedAttributeArray) {\n    _vA.fromBufferAttribute(attribute, a2);\n    _vB.fromBufferAttribute(attribute, b2);\n    _vC.fromBufferAttribute(attribute, c2);\n    const morphInfluences = object2.morphTargetInfluences;\n    if (\n      // @ts-ignore\n      material2.morphTargets && morphAttribute && morphInfluences\n    ) {\n      _morphA.set(0, 0, 0);\n      _morphB.set(0, 0, 0);\n      _morphC.set(0, 0, 0);\n      for (let i2 = 0, il2 = morphAttribute.length; i2 < il2; i2++) {\n        const influence = morphInfluences[i2];\n        const morph = morphAttribute[i2];\n        if (influence === 0)\n          continue;\n        _tempA.fromBufferAttribute(morph, a2);\n        _tempB.fromBufferAttribute(morph, b2);\n        _tempC.fromBufferAttribute(morph, c2);\n        if (morphTargetsRelative2) {\n          _morphA.addScaledVector(_tempA, influence);\n          _morphB.addScaledVector(_tempB, influence);\n          _morphC.addScaledVector(_tempC, influence);\n        } else {\n          _morphA.addScaledVector(_tempA.sub(_vA), influence);\n          _morphB.addScaledVector(_tempB.sub(_vB), influence);\n          _morphC.addScaledVector(_tempC.sub(_vC), influence);\n        }\n      }\n      _vA.add(_morphA);\n      _vB.add(_morphB);\n      _vC.add(_morphC);\n    }\n    if (object2.isSkinnedMesh) {\n      object2.boneTransform(a2, _vA);\n      object2.boneTransform(b2, _vB);\n      object2.boneTransform(c2, _vC);\n    }\n    modifiedAttributeArray[a2 * 3 + 0] = _vA.x;\n    modifiedAttributeArray[a2 * 3 + 1] = _vA.y;\n    modifiedAttributeArray[a2 * 3 + 2] = _vA.z;\n    modifiedAttributeArray[b2 * 3 + 0] = _vB.x;\n    modifiedAttributeArray[b2 * 3 + 1] = _vB.y;\n    modifiedAttributeArray[b2 * 3 + 2] = _vB.z;\n    modifiedAttributeArray[c2 * 3 + 0] = _vC.x;\n    modifiedAttributeArray[c2 * 3 + 1] = _vC.y;\n    modifiedAttributeArray[c2 * 3 + 2] = _vC.z;\n  }\n  const geometry = object.geometry;\n  const material = object.material;\n  let a, b, c;\n  const index = geometry.index;\n  const positionAttribute = geometry.attributes.position;\n  const morphPosition = geometry.morphAttributes.position;\n  const morphTargetsRelative = geometry.morphTargetsRelative;\n  const normalAttribute = geometry.attributes.normal;\n  const morphNormal = geometry.morphAttributes.position;\n  const groups = geometry.groups;\n  const drawRange = geometry.drawRange;\n  let i, j, il, jl;\n  let group, groupMaterial;\n  let start, end;\n  const modifiedPosition = new Float32Array(positionAttribute.count * positionAttribute.itemSize);\n  const modifiedNormal = new Float32Array(normalAttribute.count * normalAttribute.itemSize);\n  if (index !== null) {\n    if (Array.isArray(material)) {\n      for (i = 0, il = groups.length; i < il; i++) {\n        group = groups[i];\n        groupMaterial = material[group.materialIndex];\n        start = Math.max(group.start, drawRange.start);\n        end = Math.min(group.start + group.count, drawRange.start + drawRange.count);\n        for (j = start, jl = end; j < jl; j += 3) {\n          a = index.getX(j);\n          b = index.getX(j + 1);\n          c = index.getX(j + 2);\n          _calculateMorphedAttributeData(\n            object,\n            groupMaterial,\n            positionAttribute,\n            morphPosition,\n            morphTargetsRelative,\n            a,\n            b,\n            c,\n            modifiedPosition\n          );\n          _calculateMorphedAttributeData(\n            object,\n            groupMaterial,\n            normalAttribute,\n            morphNormal,\n            morphTargetsRelative,\n            a,\n            b,\n            c,\n            modifiedNormal\n          );\n        }\n      }\n    } else {\n      start = Math.max(0, drawRange.start);\n      end = Math.min(index.count, drawRange.start + drawRange.count);\n      for (i = start, il = end; i < il; i += 3) {\n        a = index.getX(i);\n        b = index.getX(i + 1);\n        c = index.getX(i + 2);\n        _calculateMorphedAttributeData(\n          object,\n          material,\n          positionAttribute,\n          morphPosition,\n          morphTargetsRelative,\n          a,\n          b,\n          c,\n          modifiedPosition\n        );\n        _calculateMorphedAttributeData(\n          object,\n          material,\n          normalAttribute,\n          morphNormal,\n          morphTargetsRelative,\n          a,\n          b,\n          c,\n          modifiedNormal\n        );\n      }\n    }\n  } else if (positionAttribute !== void 0) {\n    if (Array.isArray(material)) {\n      for (i = 0, il = groups.length; i < il; i++) {\n        group = groups[i];\n        groupMaterial = material[group.materialIndex];\n        start = Math.max(group.start, drawRange.start);\n        end = Math.min(group.start + group.count, drawRange.start + drawRange.count);\n        for (j = start, jl = end; j < jl; j += 3) {\n          a = j;\n          b = j + 1;\n          c = j + 2;\n          _calculateMorphedAttributeData(\n            object,\n            groupMaterial,\n            positionAttribute,\n            morphPosition,\n            morphTargetsRelative,\n            a,\n            b,\n            c,\n            modifiedPosition\n          );\n          _calculateMorphedAttributeData(\n            object,\n            groupMaterial,\n            normalAttribute,\n            morphNormal,\n            morphTargetsRelative,\n            a,\n            b,\n            c,\n            modifiedNormal\n          );\n        }\n      }\n    } else {\n      start = Math.max(0, drawRange.start);\n      end = Math.min(positionAttribute.count, drawRange.start + drawRange.count);\n      for (i = start, il = end; i < il; i += 3) {\n        a = i;\n        b = i + 1;\n        c = i + 2;\n        _calculateMorphedAttributeData(\n          object,\n          material,\n          positionAttribute,\n          morphPosition,\n          morphTargetsRelative,\n          a,\n          b,\n          c,\n          modifiedPosition\n        );\n        _calculateMorphedAttributeData(\n          object,\n          material,\n          normalAttribute,\n          morphNormal,\n          morphTargetsRelative,\n          a,\n          b,\n          c,\n          modifiedNormal\n        );\n      }\n    }\n  }\n  const morphedPositionAttribute = new Float32BufferAttribute(modifiedPosition, 3);\n  const morphedNormalAttribute = new Float32BufferAttribute(modifiedNormal, 3);\n  return {\n    positionAttribute,\n    normalAttribute,\n    morphedPositionAttribute,\n    morphedNormalAttribute\n  };\n}\nfunction toCreasedNormals(geometry, creaseAngle = Math.PI / 3) {\n  const creaseDot = Math.cos(creaseAngle);\n  const hashMultiplier = (1 + 1e-10) * 100;\n  const verts = [new Vector3(), new Vector3(), new Vector3()];\n  const tempVec1 = new Vector3();\n  const tempVec2 = new Vector3();\n  const tempNorm = new Vector3();\n  const tempNorm2 = new Vector3();\n  function hashVertex(v) {\n    const x = ~~(v.x * hashMultiplier);\n    const y = ~~(v.y * hashMultiplier);\n    const z = ~~(v.z * hashMultiplier);\n    return `${x},${y},${z}`;\n  }\n  const resultGeometry = geometry.index ? geometry.toNonIndexed() : geometry;\n  const posAttr = resultGeometry.attributes.position;\n  const vertexMap = {};\n  for (let i = 0, l = posAttr.count / 3; i < l; i++) {\n    const i3 = 3 * i;\n    const a = verts[0].fromBufferAttribute(posAttr, i3 + 0);\n    const b = verts[1].fromBufferAttribute(posAttr, i3 + 1);\n    const c = verts[2].fromBufferAttribute(posAttr, i3 + 2);\n    tempVec1.subVectors(c, b);\n    tempVec2.subVectors(a, b);\n    const normal = new Vector3().crossVectors(tempVec1, tempVec2).normalize();\n    for (let n = 0; n < 3; n++) {\n      const vert = verts[n];\n      const hash = hashVertex(vert);\n      if (!(hash in vertexMap)) {\n        vertexMap[hash] = [];\n      }\n      vertexMap[hash].push(normal);\n    }\n  }\n  const normalArray = new Float32Array(posAttr.count * 3);\n  const normAttr = new BufferAttribute(normalArray, 3, false);\n  for (let i = 0, l = posAttr.count / 3; i < l; i++) {\n    const i3 = 3 * i;\n    const a = verts[0].fromBufferAttribute(posAttr, i3 + 0);\n    const b = verts[1].fromBufferAttribute(posAttr, i3 + 1);\n    const c = verts[2].fromBufferAttribute(posAttr, i3 + 2);\n    tempVec1.subVectors(c, b);\n    tempVec2.subVectors(a, b);\n    tempNorm.crossVectors(tempVec1, tempVec2).normalize();\n    for (let n = 0; n < 3; n++) {\n      const vert = verts[n];\n      const hash = hashVertex(vert);\n      const otherNormals = vertexMap[hash];\n      tempNorm2.set(0, 0, 0);\n      for (let k = 0, lk = otherNormals.length; k < lk; k++) {\n        const otherNorm = otherNormals[k];\n        if (tempNorm.dot(otherNorm) > creaseDot) {\n          tempNorm2.add(otherNorm);\n        }\n      }\n      tempNorm2.normalize();\n      normAttr.setXYZ(i3 + n, tempNorm2.x, tempNorm2.y, tempNorm2.z);\n    }\n  }\n  resultGeometry.setAttribute(\"normal\", normAttr);\n  return resultGeometry;\n}\nexport {\n  computeMorphedAttributes,\n  estimateBytesUsed,\n  interleaveAttributes,\n  mergeBufferAttributes,\n  mergeBufferGeometries,\n  mergeVertices,\n  toCreasedNormals,\n  toTrianglesDrawMode\n};\n//# sourceMappingURL=BufferGeometryUtils.js.map\n"],"mappings":"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"}