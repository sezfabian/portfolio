{"version":3,"file":"@react-three_rapier.js","names":["r","Vector3$1","Quaternion$1","ColliderDesc","ActiveEvents","EventQueue","RigidBodyDesc","Fragment","index"],"sources":["../../@react-three/rapier/dist/react-three-rapier.esm.js"],"sourcesContent":["import { Vector3 as Vector3$1, Quaternion as Quaternion$1, ActiveEvents, ColliderDesc, EventQueue, RigidBodyDesc } from '@dimforge/rapier3d-compat';\nexport { CoefficientCombineRule, Collider as RapierCollider, RigidBody as RapierRigidBody } from '@dimforge/rapier3d-compat';\nimport { useFrame, useThree } from '@react-three/fiber';\nimport React, { useRef, useEffect, memo, useMemo, useContext, useState, createContext, useCallback, Fragment } from 'react';\nimport { Quaternion, Euler, Vector3, Object3D, Matrix4, BufferGeometry, BufferAttribute, MathUtils, DynamicDrawUsage } from 'three';\nimport { suspend } from 'suspend-react';\nimport { mergeVertices } from 'three-stdlib';\n\nfunction _toPrimitive(t, r) {\n  if (\"object\" != typeof t || !t) return t;\n  var e = t[Symbol.toPrimitive];\n  if (void 0 !== e) {\n    var i = e.call(t, r || \"default\");\n    if (\"object\" != typeof i) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (\"string\" === r ? String : Number)(t);\n}\n\nfunction _toPropertyKey(t) {\n  var i = _toPrimitive(t, \"string\");\n  return \"symbol\" == typeof i ? i : i + \"\";\n}\n\nfunction _defineProperty(e, r, t) {\n  return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {\n    value: t,\n    enumerable: !0,\n    configurable: !0,\n    writable: !0\n  }) : e[r] = t, e;\n}\n\nfunction ownKeys(e, r) {\n  var t = Object.keys(e);\n  if (Object.getOwnPropertySymbols) {\n    var o = Object.getOwnPropertySymbols(e);\n    r && (o = o.filter(function (r) {\n      return Object.getOwnPropertyDescriptor(e, r).enumerable;\n    })), t.push.apply(t, o);\n  }\n  return t;\n}\nfunction _objectSpread2(e) {\n  for (var r = 1; r < arguments.length; r++) {\n    var t = null != arguments[r] ? arguments[r] : {};\n    r % 2 ? ownKeys(Object(t), !0).forEach(function (r) {\n      _defineProperty(e, r, t[r]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {\n      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n    });\n  }\n  return e;\n}\n\nconst _quaternion = new Quaternion();\nnew Euler();\nconst _vector3 = new Vector3();\nnew Object3D();\nconst _matrix4 = new Matrix4();\nconst _position = new Vector3();\nconst _rotation = new Quaternion();\nconst _scale = new Vector3();\n\nconst vectorArrayToVector3 = arr => {\n  const [x, y, z] = arr;\n  return new Vector3(x, y, z);\n};\nconst rapierQuaternionToQuaternion = ({\n  x,\n  y,\n  z,\n  w\n}) => _quaternion.set(x, y, z, w);\nconst vector3ToRapierVector = v => {\n  if (Array.isArray(v)) {\n    return new Vector3$1(v[0], v[1], v[2]);\n  } else if (typeof v === \"number\") {\n    return new Vector3$1(v, v, v);\n  } else {\n    const threeVector3 = v;\n    return new Vector3$1(threeVector3.x, threeVector3.y, threeVector3.z);\n  }\n};\nconst quaternionToRapierQuaternion = v => {\n  if (Array.isArray(v)) {\n    return new Quaternion$1(v[0], v[1], v[2], v[3]);\n  } else {\n    return new Quaternion$1(v.x, v.y, v.z, v.w);\n  }\n};\nconst rigidBodyTypeMap = {\n  fixed: 1,\n  dynamic: 0,\n  kinematicPosition: 2,\n  kinematicVelocity: 3\n};\nconst rigidBodyTypeFromString = type => rigidBodyTypeMap[type];\nconst scaleVertices = (vertices, scale) => {\n  const scaledVerts = Array.from(vertices);\n  for (let i = 0; i < vertices.length / 3; i++) {\n    scaledVerts[i * 3] *= scale.x;\n    scaledVerts[i * 3 + 1] *= scale.y;\n    scaledVerts[i * 3 + 2] *= scale.z;\n  }\n  return scaledVerts;\n};\nconst vectorToTuple = v => {\n  if (!v) return [0];\n  if (v instanceof Quaternion) {\n    return [v.x, v.y, v.z, v.w];\n  }\n  if (v instanceof Vector3 || v instanceof Euler) {\n    return [v.x, v.y, v.z];\n  }\n  if (Array.isArray(v)) {\n    return v;\n  }\n  return [v];\n};\nfunction useConst(initialValue) {\n  const ref = useRef(undefined);\n  if (ref.current === undefined) {\n    ref.current = {\n      value: typeof initialValue === \"function\" ? initialValue() : initialValue\n    };\n  }\n  return ref.current.value;\n}\n\nconst useRaf = callback => {\n  const cb = useRef(callback);\n  const raf = useRef(0);\n  const lastFrame = useRef(0);\n  useEffect(() => {\n    cb.current = callback;\n  }, [callback]);\n  useEffect(() => {\n    const loop = () => {\n      const now = performance.now();\n      const delta = now - lastFrame.current;\n      raf.current = requestAnimationFrame(loop);\n      cb.current(delta / 1000);\n      lastFrame.current = now;\n    };\n    raf.current = requestAnimationFrame(loop);\n    return () => cancelAnimationFrame(raf.current);\n  }, []);\n};\n\nconst UseFrameStepper = ({\n  onStep,\n  updatePriority\n}) => {\n  useFrame((_, dt) => {\n    onStep(dt);\n  }, updatePriority);\n  return null;\n};\nconst RafStepper = ({\n  onStep\n}) => {\n  useRaf(dt => {\n    onStep(dt);\n  });\n  return null;\n};\nconst FrameStepper = ({\n  onStep,\n  type,\n  updatePriority\n}) => {\n  return type === \"independent\" ? /*#__PURE__*/React.createElement(RafStepper, {\n    onStep: onStep\n  }) : /*#__PURE__*/React.createElement(UseFrameStepper, {\n    onStep: onStep,\n    updatePriority: updatePriority\n  });\n};\nvar FrameStepper$1 = /*#__PURE__*/memo(FrameStepper);\n\nfunction _objectWithoutPropertiesLoose(r, e) {\n  if (null == r) return {};\n  var t = {};\n  for (var n in r) if ({}.hasOwnProperty.call(r, n)) {\n    if (-1 !== e.indexOf(n)) continue;\n    t[n] = r[n];\n  }\n  return t;\n}\n\nfunction _objectWithoutProperties(e, t) {\n  if (null == e) return {};\n  var o,\n    r,\n    i = _objectWithoutPropertiesLoose(e, t);\n  if (Object.getOwnPropertySymbols) {\n    var n = Object.getOwnPropertySymbols(e);\n    for (r = 0; r < n.length; r++) o = n[r], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);\n  }\n  return i;\n}\n\nconst _excluded$2 = [\"mass\", \"linearDamping\", \"angularDamping\", \"type\", \"onCollisionEnter\", \"onCollisionExit\", \"onIntersectionEnter\", \"onIntersectionExit\", \"onContactForce\", \"children\", \"canSleep\", \"ccd\", \"gravityScale\", \"softCcdPrediction\", \"ref\"];\nconst scaleColliderArgs = (shape, args, scale) => {\n  const newArgs = args.slice();\n\n  // Heightfield uses a vector\n  if (shape === \"heightfield\") {\n    const s = newArgs[3];\n    s.x *= scale.x;\n    s.x *= scale.y;\n    s.x *= scale.z;\n    return newArgs;\n  }\n\n  // Trimesh and convex scale the vertices\n  if (shape === \"trimesh\" || shape === \"convexHull\") {\n    newArgs[0] = scaleVertices(newArgs[0], scale);\n    return newArgs;\n  }\n\n  // Prepfill with some extra\n  const scaleArray = [scale.x, scale.y, scale.z, scale.x, scale.x];\n  return newArgs.map((arg, index) => scaleArray[index] * arg);\n};\nconst createColliderFromOptions = (options, world, scale, getRigidBody) => {\n  const scaledArgs = scaleColliderArgs(options.shape, options.args, scale);\n  // @ts-ignore\n  const desc = ColliderDesc[options.shape](...scaledArgs);\n  return world.createCollider(desc, getRigidBody === null || getRigidBody === void 0 ? void 0 : getRigidBody());\n};\nconst immutableColliderOptions = [\"shape\", \"args\"];\nconst massPropertiesConflictError = \"Please pick ONLY ONE of the `density`, `mass` and `massProperties` options.\";\nconst setColliderMassOptions = (collider, options) => {\n  if (options.density !== undefined) {\n    if (options.mass !== undefined || options.massProperties !== undefined) {\n      throw new Error(massPropertiesConflictError);\n    }\n    collider.setDensity(options.density);\n    return;\n  }\n  if (options.mass !== undefined) {\n    if (options.massProperties !== undefined) {\n      throw new Error(massPropertiesConflictError);\n    }\n    collider.setMass(options.mass);\n    return;\n  }\n  if (options.massProperties !== undefined) {\n    collider.setMassProperties(options.massProperties.mass, options.massProperties.centerOfMass, options.massProperties.principalAngularInertia, options.massProperties.angularInertiaLocalFrame);\n  }\n};\nconst mutableColliderOptions = {\n  sensor: (collider, value) => {\n    collider.setSensor(value);\n  },\n  collisionGroups: (collider, value) => {\n    collider.setCollisionGroups(value);\n  },\n  solverGroups: (collider, value) => {\n    collider.setSolverGroups(value);\n  },\n  friction: (collider, value) => {\n    collider.setFriction(value);\n  },\n  frictionCombineRule: (collider, value) => {\n    collider.setFrictionCombineRule(value);\n  },\n  restitution: (collider, value) => {\n    collider.setRestitution(value);\n  },\n  restitutionCombineRule: (collider, value) => {\n    collider.setRestitutionCombineRule(value);\n  },\n  activeCollisionTypes: (collider, value) => {\n    collider.setActiveCollisionTypes(value);\n  },\n  contactSkin: (collider, value) => {\n    collider.setContactSkin(value);\n  },\n  // To make sure the options all mutable options are listed\n  quaternion: () => {},\n  position: () => {},\n  rotation: () => {},\n  scale: () => {}\n};\nconst mutableColliderOptionKeys = Object.keys(mutableColliderOptions);\nconst setColliderOptions = (collider, options, states) => {\n  const state = states.get(collider.handle);\n  if (state) {\n    var _state$worldParent;\n    // Update collider position based on the object's position\n    const parentWorldScale = state.object.parent.getWorldScale(_vector3);\n    const parentInvertedWorldMatrix = (_state$worldParent = state.worldParent) === null || _state$worldParent === void 0 ? void 0 : _state$worldParent.matrixWorld.clone().invert();\n    state.object.updateWorldMatrix(true, false);\n    _matrix4.copy(state.object.matrixWorld);\n    if (parentInvertedWorldMatrix) {\n      _matrix4.premultiply(parentInvertedWorldMatrix);\n    }\n    _matrix4.decompose(_position, _rotation, _scale);\n    if (collider.parent()) {\n      collider.setTranslationWrtParent({\n        x: _position.x * parentWorldScale.x,\n        y: _position.y * parentWorldScale.y,\n        z: _position.z * parentWorldScale.z\n      });\n      collider.setRotationWrtParent(_rotation);\n    } else {\n      collider.setTranslation({\n        x: _position.x * parentWorldScale.x,\n        y: _position.y * parentWorldScale.y,\n        z: _position.z * parentWorldScale.z\n      });\n      collider.setRotation(_rotation);\n    }\n    mutableColliderOptionKeys.forEach(key => {\n      if (key in options) {\n        const option = options[key];\n        mutableColliderOptions[key](collider,\n        // @ts-ignore Option does not want to fit into the function, but it will\n        option, options);\n      }\n    });\n\n    // handle mass separately, because the assignments\n    // are exclusive.\n    setColliderMassOptions(collider, options);\n  }\n};\nconst useUpdateColliderOptions = (getCollider, props, states) => {\n  // TODO: Improve this, split each prop into its own effect\n  const mutablePropsAsFlatArray = useMemo(() => mutableColliderOptionKeys.flatMap(key => {\n    return vectorToTuple(props[key]);\n  }), [props]);\n  useEffect(() => {\n    const collider = getCollider();\n    setColliderOptions(collider, props, states);\n  }, [...mutablePropsAsFlatArray, getCollider]);\n};\nconst isChildOfMeshCollider = child => {\n  let flag = false;\n  child.traverseAncestors(a => {\n    if (a.userData.r3RapierType === \"MeshCollider\") flag = true;\n  });\n  return flag;\n};\nconst createColliderState = (collider, object, rigidBodyObject) => {\n  return {\n    collider,\n    worldParent: rigidBodyObject || undefined,\n    object\n  };\n};\nconst autoColliderMap = {\n  cuboid: \"cuboid\",\n  ball: \"ball\",\n  hull: \"convexHull\",\n  trimesh: \"trimesh\"\n};\nconst createColliderPropsFromChildren = ({\n  object,\n  ignoreMeshColliders: _ignoreMeshColliders = true,\n  options\n}) => {\n  const childColliderProps = [];\n  object.updateWorldMatrix(true, false);\n  const invertedParentMatrixWorld = object.matrixWorld.clone().invert();\n  const colliderFromChild = child => {\n    if (\"isMesh\" in child) {\n      if (_ignoreMeshColliders && isChildOfMeshCollider(child)) return;\n      const worldScale = child.getWorldScale(_scale);\n      const shape = autoColliderMap[options.colliders || \"cuboid\"];\n      child.updateWorldMatrix(true, false);\n      _matrix4.copy(child.matrixWorld).premultiply(invertedParentMatrixWorld).decompose(_position, _rotation, _scale);\n      const rotationEuler = new Euler().setFromQuaternion(_rotation, \"XYZ\");\n      const {\n        geometry\n      } = child;\n      const {\n        args,\n        offset\n      } = getColliderArgsFromGeometry(geometry, options.colliders || \"cuboid\");\n      const colliderProps = _objectSpread2(_objectSpread2({}, cleanRigidBodyPropsForCollider(options)), {}, {\n        args: args,\n        shape: shape,\n        rotation: [rotationEuler.x, rotationEuler.y, rotationEuler.z],\n        position: [_position.x + offset.x * worldScale.x, _position.y + offset.y * worldScale.y, _position.z + offset.z * worldScale.z],\n        scale: [worldScale.x, worldScale.y, worldScale.z]\n      });\n      childColliderProps.push(colliderProps);\n    }\n  };\n  if (options.includeInvisible) {\n    object.traverse(colliderFromChild);\n  } else {\n    object.traverseVisible(colliderFromChild);\n  }\n  return childColliderProps;\n};\nconst getColliderArgsFromGeometry = (geometry, colliders) => {\n  switch (colliders) {\n    case \"cuboid\":\n      {\n        geometry.computeBoundingBox();\n        const {\n          boundingBox\n        } = geometry;\n        const size = boundingBox.getSize(new Vector3());\n        return {\n          args: [size.x / 2, size.y / 2, size.z / 2],\n          offset: boundingBox.getCenter(new Vector3())\n        };\n      }\n    case \"ball\":\n      {\n        geometry.computeBoundingSphere();\n        const {\n          boundingSphere\n        } = geometry;\n        const radius = boundingSphere.radius;\n        return {\n          args: [radius],\n          offset: boundingSphere.center\n        };\n      }\n    case \"trimesh\":\n      {\n        var _clonedGeometry$index;\n        const clonedGeometry = geometry.index ? geometry.clone() : mergeVertices(geometry);\n        return {\n          args: [clonedGeometry.attributes.position.array, (_clonedGeometry$index = clonedGeometry.index) === null || _clonedGeometry$index === void 0 ? void 0 : _clonedGeometry$index.array],\n          offset: new Vector3()\n        };\n      }\n    case \"hull\":\n      {\n        const g = geometry.clone();\n        return {\n          args: [g.attributes.position.array],\n          offset: new Vector3()\n        };\n      }\n  }\n  return {\n    args: [],\n    offset: new Vector3()\n  };\n};\nconst getActiveCollisionEventsFromProps = props => {\n  return {\n    collision: !!(props !== null && props !== void 0 && props.onCollisionEnter || props !== null && props !== void 0 && props.onCollisionExit || props !== null && props !== void 0 && props.onIntersectionEnter || props !== null && props !== void 0 && props.onIntersectionExit),\n    contactForce: !!(props !== null && props !== void 0 && props.onContactForce)\n  };\n};\nconst useColliderEvents = (getCollider, props, events,\n/**\n * The RigidBody can pass down active events to the collider without attaching the event listners\n */\nactiveEvents = {}) => {\n  const {\n    onCollisionEnter,\n    onCollisionExit,\n    onIntersectionEnter,\n    onIntersectionExit,\n    onContactForce\n  } = props;\n  useEffect(() => {\n    const collider = getCollider();\n    if (collider) {\n      const {\n        collision: collisionEventsActive,\n        contactForce: contactForceEventsActive\n      } = getActiveCollisionEventsFromProps(props);\n      const hasCollisionEvent = collisionEventsActive || activeEvents.collision;\n      const hasContactForceEvent = contactForceEventsActive || activeEvents.contactForce;\n      if (hasCollisionEvent && hasContactForceEvent) {\n        collider.setActiveEvents(ActiveEvents.COLLISION_EVENTS | ActiveEvents.CONTACT_FORCE_EVENTS);\n      } else if (hasCollisionEvent) {\n        collider.setActiveEvents(ActiveEvents.COLLISION_EVENTS);\n      } else if (hasContactForceEvent) {\n        collider.setActiveEvents(ActiveEvents.CONTACT_FORCE_EVENTS);\n      }\n      events.set(collider.handle, {\n        onCollisionEnter,\n        onCollisionExit,\n        onIntersectionEnter,\n        onIntersectionExit,\n        onContactForce\n      });\n    }\n    return () => {\n      if (collider) {\n        events.delete(collider.handle);\n      }\n    };\n  }, [onCollisionEnter, onCollisionExit, onIntersectionEnter, onIntersectionExit, onContactForce, activeEvents]);\n};\nconst cleanRigidBodyPropsForCollider = (props = {}) => {\n  const rest = _objectWithoutProperties(props, _excluded$2);\n  return rest;\n};\n\n// Utils\nconst useMutableCallback = fn => {\n  const ref = useRef(fn);\n  useEffect(() => {\n    ref.current = fn;\n  }, [fn]);\n  return ref;\n};\n\n// External hooks\n/**\n * Exposes the Rapier context, and world\n * @category Hooks\n */\nconst useRapier = () => {\n  const rapier = useContext(rapierContext);\n  if (!rapier) throw new Error(\"react-three-rapier: useRapier must be used within <Physics />!\");\n  return rapier;\n};\n\n/**\n * Registers a callback to be called before the physics step\n * @category Hooks\n */\nconst useBeforePhysicsStep = callback => {\n  const {\n    beforeStepCallbacks\n  } = useRapier();\n  const ref = useMutableCallback(callback);\n  useEffect(() => {\n    beforeStepCallbacks.add(ref);\n    return () => {\n      beforeStepCallbacks.delete(ref);\n    };\n  }, []);\n};\n\n/**\n * Registers a callback to be called after the physics step\n * @category Hooks\n */\nconst useAfterPhysicsStep = callback => {\n  const {\n    afterStepCallbacks\n  } = useRapier();\n  const ref = useMutableCallback(callback);\n  useEffect(() => {\n    afterStepCallbacks.add(ref);\n    return () => {\n      afterStepCallbacks.delete(ref);\n    };\n  }, []);\n};\n\n// Internal hooks\n/**\n * @internal\n */\nconst useChildColliderProps = (ref, options, ignoreMeshColliders = true) => {\n  const [colliderProps, setColliderProps] = useState([]);\n  useEffect(() => {\n    const object = ref.current;\n    if (object && options.colliders !== false) {\n      setColliderProps(createColliderPropsFromChildren({\n        object: ref.current,\n        options,\n        ignoreMeshColliders\n      }));\n    }\n  }, [options.colliders]);\n  return colliderProps;\n};\n\nconst Debug = /*#__PURE__*/memo(() => {\n  const {\n    world\n  } = useRapier();\n  const ref = useRef(null);\n  useFrame(() => {\n    const mesh = ref.current;\n    if (!mesh) return;\n    const buffers = world.debugRender();\n    const geometry = new BufferGeometry();\n    geometry.setAttribute(\"position\", new BufferAttribute(buffers.vertices, 3));\n    geometry.setAttribute(\"color\", new BufferAttribute(buffers.colors, 4));\n    mesh.geometry.dispose();\n    mesh.geometry = geometry;\n  });\n  return /*#__PURE__*/React.createElement(\"group\", null, /*#__PURE__*/React.createElement(\"lineSegments\", {\n    ref: ref,\n    frustumCulled: false\n  }, /*#__PURE__*/React.createElement(\"lineBasicMaterial\", {\n    color: 0xffffff,\n    vertexColors: true\n  }), /*#__PURE__*/React.createElement(\"bufferGeometry\", null)));\n});\n\n/**\n * Creates a proxy that will create a singleton instance of the given class\n * when a property is accessed, and not before.\n *\n * @returns A proxy and a reset function, so that the instance can created again\n */\nconst createSingletonProxy = createInstance => {\n  let instance;\n  const handler = {\n    get(target, prop) {\n      if (!instance) {\n        instance = createInstance();\n      }\n      return Reflect.get(instance, prop);\n    },\n    set(target, prop, value) {\n      if (!instance) {\n        instance = createInstance();\n      }\n      return Reflect.set(instance, prop, value);\n    }\n  };\n  const proxy = new Proxy({}, handler);\n  const reset = () => {\n    instance = undefined;\n  };\n  const set = newInstance => {\n    instance = newInstance;\n  };\n\n  /**\n   * Return the proxy and a reset function\n   */\n  return {\n    proxy,\n    reset,\n    set\n  };\n};\n\nconst rapierContext = /*#__PURE__*/createContext(undefined);\nconst getCollisionPayloadFromSource = (target, other) => {\n  var _target$collider$stat, _target$rigidBody$sta, _other$collider$state, _other$rigidBody$stat, _other$collider$state2, _other$rigidBody$stat2;\n  return {\n    target: {\n      rigidBody: target.rigidBody.object,\n      collider: target.collider.object,\n      colliderObject: (_target$collider$stat = target.collider.state) === null || _target$collider$stat === void 0 ? void 0 : _target$collider$stat.object,\n      rigidBodyObject: (_target$rigidBody$sta = target.rigidBody.state) === null || _target$rigidBody$sta === void 0 ? void 0 : _target$rigidBody$sta.object\n    },\n    other: {\n      rigidBody: other.rigidBody.object,\n      collider: other.collider.object,\n      colliderObject: (_other$collider$state = other.collider.state) === null || _other$collider$state === void 0 ? void 0 : _other$collider$state.object,\n      rigidBodyObject: (_other$rigidBody$stat = other.rigidBody.state) === null || _other$rigidBody$stat === void 0 ? void 0 : _other$rigidBody$stat.object\n    },\n    rigidBody: other.rigidBody.object,\n    collider: other.collider.object,\n    colliderObject: (_other$collider$state2 = other.collider.state) === null || _other$collider$state2 === void 0 ? void 0 : _other$collider$state2.object,\n    rigidBodyObject: (_other$rigidBody$stat2 = other.rigidBody.state) === null || _other$rigidBody$stat2 === void 0 ? void 0 : _other$rigidBody$stat2.object\n  };\n};\nconst importRapier = async () => {\n  let r = await import('@dimforge/rapier3d-compat');\n  await r.init();\n  return r;\n};\n/**\n * The main physics component used to create a physics world.\n * @category Components\n */\nconst Physics = props => {\n  const {\n    colliders = \"cuboid\",\n    children,\n    timeStep = 1 / 60,\n    paused = false,\n    interpolate = true,\n    updatePriority,\n    updateLoop = \"follow\",\n    debug = false,\n    gravity = [0, -9.81, 0],\n    allowedLinearError = 0.001,\n    predictionDistance = 0.002,\n    numSolverIterations = 4,\n    numAdditionalFrictionIterations = 4,\n    numInternalPgsIterations = 1,\n    minIslandSize = 128,\n    maxCcdSubsteps = 1,\n    contactNaturalFrequency = 30,\n    lengthUnit = 1\n  } = props;\n  const rapier = suspend(importRapier, [\"@react-thee/rapier\", importRapier]);\n  const {\n    invalidate\n  } = useThree();\n  const rigidBodyStates = useConst(() => new Map());\n  const colliderStates = useConst(() => new Map());\n  const rigidBodyEvents = useConst(() => new Map());\n  const colliderEvents = useConst(() => new Map());\n  const eventQueue = useConst(() => new EventQueue(false));\n  const beforeStepCallbacks = useConst(() => new Set());\n  const afterStepCallbacks = useConst(() => new Set());\n\n  /**\n   * Initiate the world\n   * This creates a singleton proxy, so that the world is only created when\n   * something within it is accessed.\n   */\n  const {\n    proxy: worldProxy,\n    reset: resetWorldProxy,\n    set: setWorldProxy\n  } = useConst(() => createSingletonProxy(() => new rapier.World(vectorArrayToVector3(gravity))));\n  useEffect(() => {\n    return () => {\n      worldProxy.free();\n      resetWorldProxy();\n    };\n  }, []);\n\n  // Update mutable props\n  useEffect(() => {\n    worldProxy.gravity = vector3ToRapierVector(gravity);\n    worldProxy.integrationParameters.numSolverIterations = numSolverIterations;\n    worldProxy.integrationParameters.numAdditionalFrictionIterations = numAdditionalFrictionIterations;\n    worldProxy.integrationParameters.numInternalPgsIterations = numInternalPgsIterations;\n    worldProxy.integrationParameters.normalizedAllowedLinearError = allowedLinearError;\n    worldProxy.integrationParameters.minIslandSize = minIslandSize;\n    worldProxy.integrationParameters.maxCcdSubsteps = maxCcdSubsteps;\n    worldProxy.integrationParameters.normalizedPredictionDistance = predictionDistance;\n    worldProxy.lengthUnit = lengthUnit;\n    worldProxy.integrationParameters.contact_natural_frequency = contactNaturalFrequency;\n  }, [worldProxy, ...gravity, numSolverIterations, numAdditionalFrictionIterations, numInternalPgsIterations, allowedLinearError, minIslandSize, maxCcdSubsteps, predictionDistance, lengthUnit, contactNaturalFrequency]);\n  const getSourceFromColliderHandle = useCallback(handle => {\n    var _collider$parent;\n    const collider = worldProxy.getCollider(handle);\n    const colEvents = colliderEvents.get(handle);\n    const colliderState = colliderStates.get(handle);\n    const rigidBodyHandle = collider === null || collider === void 0 ? void 0 : (_collider$parent = collider.parent()) === null || _collider$parent === void 0 ? void 0 : _collider$parent.handle;\n    const rigidBody = rigidBodyHandle !== undefined ? worldProxy.getRigidBody(rigidBodyHandle) : undefined;\n    const rbEvents = rigidBody && rigidBodyHandle !== undefined ? rigidBodyEvents.get(rigidBodyHandle) : undefined;\n    const rigidBodyState = rigidBodyHandle !== undefined ? rigidBodyStates.get(rigidBodyHandle) : undefined;\n    const source = {\n      collider: {\n        object: collider,\n        events: colEvents,\n        state: colliderState\n      },\n      rigidBody: {\n        object: rigidBody,\n        events: rbEvents,\n        state: rigidBodyState\n      }\n    };\n    return source;\n  }, []);\n  const [steppingState] = useState({\n    previousState: {},\n    accumulator: 0\n  });\n  const step = useCallback(dt => {\n    const world = worldProxy;\n\n    /* Check if the timestep is supposed to be variable. We'll do this here\n      once so we don't have to string-check every frame. */\n    const timeStepVariable = timeStep === \"vary\";\n\n    /**\n     * Fixed timeStep simulation progression\n     * @see https://gafferongames.com/post/fix_your_timestep/\n     */\n\n    const clampedDelta = MathUtils.clamp(dt, 0, 0.5);\n    const stepWorld = delta => {\n      // Trigger beforeStep callbacks\n      beforeStepCallbacks.forEach(callback => {\n        callback.current(world);\n      });\n      world.timestep = delta;\n      world.step(eventQueue);\n\n      // Trigger afterStep callbacks\n      afterStepCallbacks.forEach(callback => {\n        callback.current(world);\n      });\n    };\n    if (timeStepVariable) {\n      stepWorld(clampedDelta);\n    } else {\n      // don't step time forwards if paused\n      // Increase accumulator\n      steppingState.accumulator += clampedDelta;\n      while (steppingState.accumulator >= timeStep) {\n        // Set up previous state\n        // needed for accurate interpolations if the world steps more than once\n        if (interpolate) {\n          steppingState.previousState = {};\n          world.forEachRigidBody(body => {\n            steppingState.previousState[body.handle] = {\n              position: body.translation(),\n              rotation: body.rotation()\n            };\n          });\n        }\n        stepWorld(timeStep);\n        steppingState.accumulator -= timeStep;\n      }\n    }\n    const interpolationAlpha = timeStepVariable || !interpolate || paused ? 1 : steppingState.accumulator / timeStep;\n\n    // Update meshes\n    rigidBodyStates.forEach((state, handle) => {\n      const rigidBody = world.getRigidBody(handle);\n      const events = rigidBodyEvents.get(handle);\n      if (events !== null && events !== void 0 && events.onSleep || events !== null && events !== void 0 && events.onWake) {\n        if (rigidBody.isSleeping() && !state.isSleeping) {\n          var _events$onSleep;\n          events === null || events === void 0 ? void 0 : (_events$onSleep = events.onSleep) === null || _events$onSleep === void 0 ? void 0 : _events$onSleep.call(events);\n        }\n        if (!rigidBody.isSleeping() && state.isSleeping) {\n          var _events$onWake;\n          events === null || events === void 0 ? void 0 : (_events$onWake = events.onWake) === null || _events$onWake === void 0 ? void 0 : _events$onWake.call(events);\n        }\n        state.isSleeping = rigidBody.isSleeping();\n      }\n      if (!rigidBody || rigidBody.isSleeping() && !(\"isInstancedMesh\" in state.object) || !state.setMatrix) {\n        return;\n      }\n\n      // New states\n      let t = rigidBody.translation();\n      let r = rigidBody.rotation();\n      let previousState = steppingState.previousState[handle];\n      if (previousState) {\n        // Get previous simulated world position\n        _matrix4.compose(previousState.position, rapierQuaternionToQuaternion(previousState.rotation), state.scale).premultiply(state.invertedWorldMatrix).decompose(_position, _rotation, _scale);\n\n        // Apply previous tick position\n        if (state.meshType == \"mesh\") {\n          state.object.position.copy(_position);\n          state.object.quaternion.copy(_rotation);\n        }\n      }\n\n      // Get new position\n      _matrix4.compose(t, rapierQuaternionToQuaternion(r), state.scale).premultiply(state.invertedWorldMatrix).decompose(_position, _rotation, _scale);\n      if (state.meshType == \"instancedMesh\") {\n        state.setMatrix(_matrix4);\n      } else {\n        // Interpolate to new position\n        state.object.position.lerp(_position, interpolationAlpha);\n        state.object.quaternion.slerp(_rotation, interpolationAlpha);\n      }\n    });\n    eventQueue.drainCollisionEvents((handle1, handle2, started) => {\n      const source1 = getSourceFromColliderHandle(handle1);\n      const source2 = getSourceFromColliderHandle(handle2);\n\n      // Collision Events\n      if (!(source1 !== null && source1 !== void 0 && source1.collider.object) || !(source2 !== null && source2 !== void 0 && source2.collider.object)) {\n        return;\n      }\n      const collisionPayload1 = getCollisionPayloadFromSource(source1, source2);\n      const collisionPayload2 = getCollisionPayloadFromSource(source2, source1);\n      if (started) {\n        world.contactPair(source1.collider.object, source2.collider.object, (manifold, flipped) => {\n          var _source1$rigidBody$ev, _source1$rigidBody$ev2, _source2$rigidBody$ev, _source2$rigidBody$ev2, _source1$collider$eve, _source1$collider$eve2, _source2$collider$eve, _source2$collider$eve2;\n          /* RigidBody events */\n          (_source1$rigidBody$ev = source1.rigidBody.events) === null || _source1$rigidBody$ev === void 0 ? void 0 : (_source1$rigidBody$ev2 = _source1$rigidBody$ev.onCollisionEnter) === null || _source1$rigidBody$ev2 === void 0 ? void 0 : _source1$rigidBody$ev2.call(_source1$rigidBody$ev, _objectSpread2(_objectSpread2({}, collisionPayload1), {}, {\n            manifold,\n            flipped\n          }));\n          (_source2$rigidBody$ev = source2.rigidBody.events) === null || _source2$rigidBody$ev === void 0 ? void 0 : (_source2$rigidBody$ev2 = _source2$rigidBody$ev.onCollisionEnter) === null || _source2$rigidBody$ev2 === void 0 ? void 0 : _source2$rigidBody$ev2.call(_source2$rigidBody$ev, _objectSpread2(_objectSpread2({}, collisionPayload2), {}, {\n            manifold,\n            flipped\n          }));\n\n          /* Collider events */\n          (_source1$collider$eve = source1.collider.events) === null || _source1$collider$eve === void 0 ? void 0 : (_source1$collider$eve2 = _source1$collider$eve.onCollisionEnter) === null || _source1$collider$eve2 === void 0 ? void 0 : _source1$collider$eve2.call(_source1$collider$eve, _objectSpread2(_objectSpread2({}, collisionPayload1), {}, {\n            manifold,\n            flipped\n          }));\n          (_source2$collider$eve = source2.collider.events) === null || _source2$collider$eve === void 0 ? void 0 : (_source2$collider$eve2 = _source2$collider$eve.onCollisionEnter) === null || _source2$collider$eve2 === void 0 ? void 0 : _source2$collider$eve2.call(_source2$collider$eve, _objectSpread2(_objectSpread2({}, collisionPayload2), {}, {\n            manifold,\n            flipped\n          }));\n        });\n      } else {\n        var _source1$rigidBody$ev3, _source1$rigidBody$ev4, _source2$rigidBody$ev3, _source2$rigidBody$ev4, _source1$collider$eve3, _source1$collider$eve4, _source2$collider$eve3, _source2$collider$eve4;\n        (_source1$rigidBody$ev3 = source1.rigidBody.events) === null || _source1$rigidBody$ev3 === void 0 ? void 0 : (_source1$rigidBody$ev4 = _source1$rigidBody$ev3.onCollisionExit) === null || _source1$rigidBody$ev4 === void 0 ? void 0 : _source1$rigidBody$ev4.call(_source1$rigidBody$ev3, collisionPayload1);\n        (_source2$rigidBody$ev3 = source2.rigidBody.events) === null || _source2$rigidBody$ev3 === void 0 ? void 0 : (_source2$rigidBody$ev4 = _source2$rigidBody$ev3.onCollisionExit) === null || _source2$rigidBody$ev4 === void 0 ? void 0 : _source2$rigidBody$ev4.call(_source2$rigidBody$ev3, collisionPayload2);\n        (_source1$collider$eve3 = source1.collider.events) === null || _source1$collider$eve3 === void 0 ? void 0 : (_source1$collider$eve4 = _source1$collider$eve3.onCollisionExit) === null || _source1$collider$eve4 === void 0 ? void 0 : _source1$collider$eve4.call(_source1$collider$eve3, collisionPayload1);\n        (_source2$collider$eve3 = source2.collider.events) === null || _source2$collider$eve3 === void 0 ? void 0 : (_source2$collider$eve4 = _source2$collider$eve3.onCollisionExit) === null || _source2$collider$eve4 === void 0 ? void 0 : _source2$collider$eve4.call(_source2$collider$eve3, collisionPayload2);\n      }\n\n      // Sensor Intersections\n      if (started) {\n        if (world.intersectionPair(source1.collider.object, source2.collider.object)) {\n          var _source1$rigidBody$ev5, _source1$rigidBody$ev6, _source2$rigidBody$ev5, _source2$rigidBody$ev6, _source1$collider$eve5, _source1$collider$eve6, _source2$collider$eve5, _source2$collider$eve6;\n          (_source1$rigidBody$ev5 = source1.rigidBody.events) === null || _source1$rigidBody$ev5 === void 0 ? void 0 : (_source1$rigidBody$ev6 = _source1$rigidBody$ev5.onIntersectionEnter) === null || _source1$rigidBody$ev6 === void 0 ? void 0 : _source1$rigidBody$ev6.call(_source1$rigidBody$ev5, collisionPayload1);\n          (_source2$rigidBody$ev5 = source2.rigidBody.events) === null || _source2$rigidBody$ev5 === void 0 ? void 0 : (_source2$rigidBody$ev6 = _source2$rigidBody$ev5.onIntersectionEnter) === null || _source2$rigidBody$ev6 === void 0 ? void 0 : _source2$rigidBody$ev6.call(_source2$rigidBody$ev5, collisionPayload2);\n          (_source1$collider$eve5 = source1.collider.events) === null || _source1$collider$eve5 === void 0 ? void 0 : (_source1$collider$eve6 = _source1$collider$eve5.onIntersectionEnter) === null || _source1$collider$eve6 === void 0 ? void 0 : _source1$collider$eve6.call(_source1$collider$eve5, collisionPayload1);\n          (_source2$collider$eve5 = source2.collider.events) === null || _source2$collider$eve5 === void 0 ? void 0 : (_source2$collider$eve6 = _source2$collider$eve5.onIntersectionEnter) === null || _source2$collider$eve6 === void 0 ? void 0 : _source2$collider$eve6.call(_source2$collider$eve5, collisionPayload2);\n        }\n      } else {\n        var _source1$rigidBody$ev7, _source1$rigidBody$ev8, _source2$rigidBody$ev7, _source2$rigidBody$ev8, _source1$collider$eve7, _source1$collider$eve8, _source2$collider$eve7, _source2$collider$eve8;\n        (_source1$rigidBody$ev7 = source1.rigidBody.events) === null || _source1$rigidBody$ev7 === void 0 ? void 0 : (_source1$rigidBody$ev8 = _source1$rigidBody$ev7.onIntersectionExit) === null || _source1$rigidBody$ev8 === void 0 ? void 0 : _source1$rigidBody$ev8.call(_source1$rigidBody$ev7, collisionPayload1);\n        (_source2$rigidBody$ev7 = source2.rigidBody.events) === null || _source2$rigidBody$ev7 === void 0 ? void 0 : (_source2$rigidBody$ev8 = _source2$rigidBody$ev7.onIntersectionExit) === null || _source2$rigidBody$ev8 === void 0 ? void 0 : _source2$rigidBody$ev8.call(_source2$rigidBody$ev7, collisionPayload2);\n        (_source1$collider$eve7 = source1.collider.events) === null || _source1$collider$eve7 === void 0 ? void 0 : (_source1$collider$eve8 = _source1$collider$eve7.onIntersectionExit) === null || _source1$collider$eve8 === void 0 ? void 0 : _source1$collider$eve8.call(_source1$collider$eve7, collisionPayload1);\n        (_source2$collider$eve7 = source2.collider.events) === null || _source2$collider$eve7 === void 0 ? void 0 : (_source2$collider$eve8 = _source2$collider$eve7.onIntersectionExit) === null || _source2$collider$eve8 === void 0 ? void 0 : _source2$collider$eve8.call(_source2$collider$eve7, collisionPayload2);\n      }\n    });\n    eventQueue.drainContactForceEvents(event => {\n      var _source1$rigidBody$ev9, _source1$rigidBody$ev10, _source2$rigidBody$ev9, _source2$rigidBody$ev10, _source1$collider$eve9, _source1$collider$eve10, _source2$collider$eve9, _source2$collider$eve10;\n      const source1 = getSourceFromColliderHandle(event.collider1());\n      const source2 = getSourceFromColliderHandle(event.collider2());\n\n      // Collision Events\n      if (!(source1 !== null && source1 !== void 0 && source1.collider.object) || !(source2 !== null && source2 !== void 0 && source2.collider.object)) {\n        return;\n      }\n      const collisionPayload1 = getCollisionPayloadFromSource(source1, source2);\n      const collisionPayload2 = getCollisionPayloadFromSource(source2, source1);\n      (_source1$rigidBody$ev9 = source1.rigidBody.events) === null || _source1$rigidBody$ev9 === void 0 ? void 0 : (_source1$rigidBody$ev10 = _source1$rigidBody$ev9.onContactForce) === null || _source1$rigidBody$ev10 === void 0 ? void 0 : _source1$rigidBody$ev10.call(_source1$rigidBody$ev9, _objectSpread2(_objectSpread2({}, collisionPayload1), {}, {\n        totalForce: event.totalForce(),\n        totalForceMagnitude: event.totalForceMagnitude(),\n        maxForceDirection: event.maxForceDirection(),\n        maxForceMagnitude: event.maxForceMagnitude()\n      }));\n      (_source2$rigidBody$ev9 = source2.rigidBody.events) === null || _source2$rigidBody$ev9 === void 0 ? void 0 : (_source2$rigidBody$ev10 = _source2$rigidBody$ev9.onContactForce) === null || _source2$rigidBody$ev10 === void 0 ? void 0 : _source2$rigidBody$ev10.call(_source2$rigidBody$ev9, _objectSpread2(_objectSpread2({}, collisionPayload2), {}, {\n        totalForce: event.totalForce(),\n        totalForceMagnitude: event.totalForceMagnitude(),\n        maxForceDirection: event.maxForceDirection(),\n        maxForceMagnitude: event.maxForceMagnitude()\n      }));\n      (_source1$collider$eve9 = source1.collider.events) === null || _source1$collider$eve9 === void 0 ? void 0 : (_source1$collider$eve10 = _source1$collider$eve9.onContactForce) === null || _source1$collider$eve10 === void 0 ? void 0 : _source1$collider$eve10.call(_source1$collider$eve9, _objectSpread2(_objectSpread2({}, collisionPayload1), {}, {\n        totalForce: event.totalForce(),\n        totalForceMagnitude: event.totalForceMagnitude(),\n        maxForceDirection: event.maxForceDirection(),\n        maxForceMagnitude: event.maxForceMagnitude()\n      }));\n      (_source2$collider$eve9 = source2.collider.events) === null || _source2$collider$eve9 === void 0 ? void 0 : (_source2$collider$eve10 = _source2$collider$eve9.onContactForce) === null || _source2$collider$eve10 === void 0 ? void 0 : _source2$collider$eve10.call(_source2$collider$eve9, _objectSpread2(_objectSpread2({}, collisionPayload2), {}, {\n        totalForce: event.totalForce(),\n        totalForceMagnitude: event.totalForceMagnitude(),\n        maxForceDirection: event.maxForceDirection(),\n        maxForceMagnitude: event.maxForceMagnitude()\n      }));\n    });\n    world.forEachActiveRigidBody(() => {\n      invalidate();\n    });\n  }, [paused, timeStep, interpolate, worldProxy]);\n  const context = useMemo(() => ({\n    rapier,\n    world: worldProxy,\n    setWorld: world => {\n      setWorldProxy(world);\n    },\n    physicsOptions: {\n      colliders,\n      gravity\n    },\n    rigidBodyStates,\n    colliderStates,\n    rigidBodyEvents,\n    colliderEvents,\n    beforeStepCallbacks,\n    afterStepCallbacks,\n    isPaused: paused,\n    isDebug: debug,\n    step\n  }), [paused, step, debug, colliders, gravity]);\n  const stepCallback = useCallback(delta => {\n    if (!paused) {\n      step(delta);\n    }\n  }, [paused, step]);\n  return /*#__PURE__*/React.createElement(rapierContext.Provider, {\n    value: context\n  }, /*#__PURE__*/React.createElement(FrameStepper$1, {\n    onStep: stepCallback,\n    type: updateLoop,\n    updatePriority: updatePriority\n  }), debug && /*#__PURE__*/React.createElement(Debug, null), children);\n};\n\nfunction _extends() {\n  return _extends = Object.assign ? Object.assign.bind() : function (n) {\n    for (var e = 1; e < arguments.length; e++) {\n      var t = arguments[e];\n      for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);\n    }\n    return n;\n  }, _extends.apply(null, arguments);\n}\n\n// Need to catch the case where forwardedRef is a function... how to do that?\nconst useForwardedRef = (forwardedRef, defaultValue = null) => {\n  const innerRef = useRef(defaultValue);\n\n  // Update the forwarded ref when the inner ref changes\n  if (forwardedRef && typeof forwardedRef !== \"function\") {\n    if (!forwardedRef.current) {\n      forwardedRef.current = innerRef.current;\n    }\n    return forwardedRef;\n  }\n  return innerRef;\n};\n\n/**\n * Initiate an instance and return a safe getter\n */\nconst useImperativeInstance = (createFn, destroyFn, dependencyList) => {\n  const ref = useRef(undefined);\n  const getInstance = useCallback(() => {\n    if (!ref.current) {\n      ref.current = createFn();\n    }\n    return ref.current;\n  }, dependencyList);\n  useEffect(() => {\n    // Save the destroy function and instance\n    const instance = getInstance();\n    const destroy = () => destroyFn(instance);\n    return () => {\n      destroy();\n      ref.current = undefined;\n    };\n  }, [getInstance]);\n  return getInstance;\n};\n\nconst rigidBodyDescFromOptions = options => {\n  var _options$canSleep;\n  const type = rigidBodyTypeFromString((options === null || options === void 0 ? void 0 : options.type) || \"dynamic\");\n  const desc = new RigidBodyDesc(type);\n\n  // Apply immutable options\n  desc.canSleep = (_options$canSleep = options === null || options === void 0 ? void 0 : options.canSleep) !== null && _options$canSleep !== void 0 ? _options$canSleep : true;\n  return desc;\n};\nconst createRigidBodyState = ({\n  rigidBody,\n  object,\n  setMatrix,\n  getMatrix,\n  worldScale,\n  meshType: _meshType = \"mesh\"\n}) => {\n  object.updateWorldMatrix(true, false);\n  const invertedWorldMatrix = object.parent.matrixWorld.clone().invert();\n  return {\n    object,\n    rigidBody,\n    invertedWorldMatrix,\n    setMatrix: setMatrix ? setMatrix : matrix => {\n      object.matrix.copy(matrix);\n    },\n    getMatrix: getMatrix ? getMatrix : matrix => matrix.copy(object.matrix),\n    scale: worldScale || object.getWorldScale(_scale).clone(),\n    isSleeping: false,\n    meshType: _meshType\n  };\n};\nconst immutableRigidBodyOptions = [\"args\", \"colliders\", \"canSleep\"];\nconst mutableRigidBodyOptions = {\n  gravityScale: (rb, value) => {\n    rb.setGravityScale(value, true);\n  },\n  additionalSolverIterations(rb, value) {\n    rb.setAdditionalSolverIterations(value);\n  },\n  linearDamping: (rb, value) => {\n    rb.setLinearDamping(value);\n  },\n  angularDamping: (rb, value) => {\n    rb.setAngularDamping(value);\n  },\n  dominanceGroup: (rb, value) => {\n    rb.setDominanceGroup(value);\n  },\n  enabledRotations: (rb, [x, y, z]) => {\n    rb.setEnabledRotations(x, y, z, true);\n  },\n  enabledTranslations: (rb, [x, y, z]) => {\n    rb.setEnabledTranslations(x, y, z, true);\n  },\n  lockRotations: (rb, value) => {\n    rb.lockRotations(value, true);\n  },\n  lockTranslations: (rb, value) => {\n    rb.lockTranslations(value, true);\n  },\n  angularVelocity: (rb, [x, y, z]) => {\n    rb.setAngvel({\n      x,\n      y,\n      z\n    }, true);\n  },\n  linearVelocity: (rb, [x, y, z]) => {\n    rb.setLinvel({\n      x,\n      y,\n      z\n    }, true);\n  },\n  ccd: (rb, value) => {\n    rb.enableCcd(value);\n  },\n  softCcdPrediction: (rb, value) => {\n    rb.setSoftCcdPrediction(value);\n  },\n  userData: (rb, value) => {\n    rb.userData = value;\n  },\n  type(rb, value) {\n    rb.setBodyType(rigidBodyTypeFromString(value), true);\n  },\n  position: () => {},\n  rotation: () => {},\n  quaternion: () => {},\n  scale: () => {}\n};\nconst mutableRigidBodyOptionKeys = Object.keys(mutableRigidBodyOptions);\nconst setRigidBodyOptions = (rigidBody, options, states, updateTranslations = true) => {\n  if (!rigidBody) {\n    return;\n  }\n  const state = states.get(rigidBody.handle);\n  if (state) {\n    if (updateTranslations) {\n      state.object.updateWorldMatrix(true, false);\n      _matrix4.copy(state.object.matrixWorld).decompose(_position, _rotation, _scale);\n      rigidBody.setTranslation(_position, false);\n      rigidBody.setRotation(_rotation, false);\n    }\n    mutableRigidBodyOptionKeys.forEach(key => {\n      if (key in options) {\n        mutableRigidBodyOptions[key](rigidBody, options[key]);\n      }\n    });\n  }\n};\nconst useUpdateRigidBodyOptions = (getRigidBody, props, states, updateTranslations = true) => {\n  // TODO: Improve this, split each prop into its own effect\n  const mutablePropsAsFlatArray = useMemo(() => mutableRigidBodyOptionKeys.flatMap(key => {\n    return vectorToTuple(props[key]);\n  }), [props]);\n  useEffect(() => {\n    const rigidBody = getRigidBody();\n    setRigidBodyOptions(rigidBody, props, states, updateTranslations);\n  }, mutablePropsAsFlatArray);\n};\nconst useRigidBodyEvents = (getRigidBody, props, events) => {\n  const {\n    onWake,\n    onSleep,\n    onCollisionEnter,\n    onCollisionExit,\n    onIntersectionEnter,\n    onIntersectionExit,\n    onContactForce\n  } = props;\n  const eventHandlers = {\n    onWake,\n    onSleep,\n    onCollisionEnter,\n    onCollisionExit,\n    onIntersectionEnter,\n    onIntersectionExit,\n    onContactForce\n  };\n  useEffect(() => {\n    const rigidBody = getRigidBody();\n    events.set(rigidBody.handle, eventHandlers);\n    return () => {\n      events.delete(rigidBody.handle);\n    };\n  }, [onWake, onSleep, onCollisionEnter, onCollisionExit, onIntersectionEnter, onIntersectionExit, onContactForce]);\n};\n\n/**\n * Takes an object resembling a Vector3 and returs a Three.Vector3\n * @category Math helpers\n */\nconst vec3 = ({\n  x,\n  y,\n  z\n} = {\n  x: 0,\n  y: 0,\n  z: 0\n}) => {\n  return new Vector3(x, y, z);\n};\n\n/**\n * Takes an object resembling a Quaternion and returs a Three.Quaternion\n * @category Math helpers\n */\nconst quat = ({\n  x,\n  y,\n  z,\n  w\n} = {\n  x: 0,\n  y: 0,\n  z: 0,\n  w: 1\n}) => {\n  return new Quaternion(x, y, z, w);\n};\n\n/**\n * Takes an object resembling an Euler and returs a Three.Euler\n * @category Math helpers\n */\nconst euler = ({\n  x,\n  y,\n  z\n} = {\n  x: 0,\n  y: 0,\n  z: 0\n}) => {\n  return new Euler(x, y, z);\n};\n\n/**\n * A collider is a shape that can be attached to a rigid body to define its physical properties.\n * @internal\n */\nconst AnyCollider = /*#__PURE__*/memo(props => {\n  const {\n    children,\n    position,\n    rotation,\n    quaternion,\n    scale,\n    name\n  } = props;\n  const {\n    world,\n    colliderEvents,\n    colliderStates\n  } = useRapier();\n  const rigidBodyContext = useRigidBodyContext();\n  const colliderRef = useForwardedRef(props.ref);\n  const objectRef = useRef(null);\n\n  // We spread the props out here to make sure that the ref is updated when the props change.\n  const immutablePropArray = immutableColliderOptions.flatMap(key =>\n  // Array.isArray(props[key]) ? [...props[key]] : props[key]\n  Array.isArray(props[key]) ? props[key] : [props[key]]);\n  const getInstance = useImperativeInstance(() => {\n    const worldScale = objectRef.current.getWorldScale(vec3());\n    const collider = createColliderFromOptions(props, world, worldScale, rigidBodyContext === null || rigidBodyContext === void 0 ? void 0 : rigidBodyContext.getRigidBody);\n    if (typeof props.ref == \"function\") {\n      props.ref(collider);\n    }\n    colliderRef.current = collider;\n    return collider;\n  }, collider => {\n    if (world.getCollider(collider.handle)) {\n      world.removeCollider(collider, true);\n    }\n  }, [...immutablePropArray, rigidBodyContext]);\n  useEffect(() => {\n    const collider = getInstance();\n    colliderStates.set(collider.handle, createColliderState(collider, objectRef.current, rigidBodyContext === null || rigidBodyContext === void 0 ? void 0 : rigidBodyContext.ref.current));\n    return () => {\n      colliderStates.delete(collider.handle);\n    };\n  }, [getInstance]);\n  const mergedProps = useMemo(() => {\n    return _objectSpread2(_objectSpread2({}, cleanRigidBodyPropsForCollider(rigidBodyContext === null || rigidBodyContext === void 0 ? void 0 : rigidBodyContext.options)), props);\n  }, [props, rigidBodyContext === null || rigidBodyContext === void 0 ? void 0 : rigidBodyContext.options]);\n  useUpdateColliderOptions(getInstance, mergedProps, colliderStates);\n  useColliderEvents(getInstance, mergedProps, colliderEvents, getActiveCollisionEventsFromProps(rigidBodyContext === null || rigidBodyContext === void 0 ? void 0 : rigidBodyContext.options));\n  return /*#__PURE__*/React.createElement(\"object3D\", {\n    position: position,\n    rotation: rotation,\n    quaternion: quaternion,\n    scale: scale,\n    ref: objectRef,\n    name: name\n  }, children);\n});\n/**\n * A cuboid collider shape\n * @category Colliders\n */\nconst CuboidCollider = /*#__PURE__*/React.forwardRef((props, ref) => {\n  return /*#__PURE__*/React.createElement(AnyCollider, _extends({}, props, {\n    shape: \"cuboid\",\n    ref: ref\n  }));\n});\nCuboidCollider.displayName = \"CuboidCollider\";\n/**\n * A round cuboid collider shape\n * @category Colliders\n */\nconst RoundCuboidCollider = /*#__PURE__*/React.forwardRef((props, ref) => /*#__PURE__*/React.createElement(AnyCollider, _extends({}, props, {\n  shape: \"roundCuboid\",\n  ref: ref\n})));\nRoundCuboidCollider.displayName = \"RoundCuboidCollider\";\n/**\n * A ball collider shape\n * @category Colliders\n */\nconst BallCollider = /*#__PURE__*/React.forwardRef((props, ref) => /*#__PURE__*/React.createElement(AnyCollider, _extends({}, props, {\n  shape: \"ball\",\n  ref: ref\n})));\nBallCollider.displayName = \"BallCollider\";\n/**\n * A capsule collider shape\n * @category Colliders\n */\nconst CapsuleCollider = /*#__PURE__*/React.forwardRef((props, ref) => /*#__PURE__*/React.createElement(AnyCollider, _extends({}, props, {\n  shape: \"capsule\",\n  ref: ref\n})));\nCapsuleCollider.displayName = \"CapsuleCollider\";\n/**\n * A heightfield collider shape\n * @category Colliders\n */\nconst HeightfieldCollider = /*#__PURE__*/React.forwardRef((props, ref) => /*#__PURE__*/React.createElement(AnyCollider, _extends({}, props, {\n  shape: \"heightfield\",\n  ref: ref\n})));\nHeightfieldCollider.displayName = \"HeightfieldCollider\";\n/**\n * A trimesh collider shape\n * @category Colliders\n */\nconst TrimeshCollider = /*#__PURE__*/React.forwardRef((props, ref) => /*#__PURE__*/React.createElement(AnyCollider, _extends({}, props, {\n  shape: \"trimesh\",\n  ref: ref\n})));\nTrimeshCollider.displayName = \"TrimeshCollider\";\n/**\n * A cone collider shape\n * @category Colliders\n */\nconst ConeCollider = /*#__PURE__*/React.forwardRef((props, ref) => /*#__PURE__*/React.createElement(AnyCollider, _extends({}, props, {\n  shape: \"cone\",\n  ref: ref\n})));\nConeCollider.displayName = \"ConeCollider\";\n/**\n * A round cylinder collider shape\n * @category Colliders\n */\nconst RoundConeCollider = /*#__PURE__*/React.forwardRef((props, ref) => /*#__PURE__*/React.createElement(AnyCollider, _extends({}, props, {\n  shape: \"roundCone\",\n  ref: ref\n})));\nRoundConeCollider.displayName = \"RoundConeCollider\";\n/**\n * A cylinder collider shape\n * @category Colliders\n */\nconst CylinderCollider = /*#__PURE__*/React.forwardRef((props, ref) => /*#__PURE__*/React.createElement(AnyCollider, _extends({}, props, {\n  shape: \"cylinder\",\n  ref: ref\n})));\nCylinderCollider.displayName = \"CylinderCollider\";\n/**\n * A round cylinder collider shape\n * @category Colliders\n */\nconst RoundCylinderCollider = /*#__PURE__*/React.forwardRef((props, ref) => /*#__PURE__*/React.createElement(AnyCollider, _extends({}, props, {\n  shape: \"roundCylinder\",\n  ref: ref\n})));\nCylinderCollider.displayName = \"RoundCylinderCollider\";\n/**\n * A convex hull collider shape\n * @category Colliders\n */\nconst ConvexHullCollider = /*#__PURE__*/React.forwardRef((props, ref) => /*#__PURE__*/React.createElement(AnyCollider, _extends({}, props, {\n  shape: \"convexHull\",\n  ref: ref\n})));\nConvexHullCollider.displayName = \"ConvexHullCollider\";\n\nconst _excluded$1 = [\"ref\", \"children\", \"type\", \"position\", \"rotation\", \"scale\", \"quaternion\", \"transformState\"];\nconst RigidBodyContext = /*#__PURE__*/createContext(undefined);\nconst useRigidBodyContext = () => useContext(RigidBodyContext);\n/**\n * A rigid body is a physical object that can be simulated by the physics engine.\n * @category Components\n */\nconst RigidBody = /*#__PURE__*/memo(props => {\n  const {\n      ref,\n      children,\n      type,\n      position,\n      rotation,\n      scale,\n      quaternion,\n      transformState\n    } = props,\n    objectProps = _objectWithoutProperties(props, _excluded$1);\n  const objectRef = useRef(null);\n  const rigidBodyRef = useForwardedRef(ref);\n  const {\n    world,\n    rigidBodyStates,\n    physicsOptions,\n    rigidBodyEvents\n  } = useRapier();\n  const mergedOptions = useMemo(() => {\n    return _objectSpread2(_objectSpread2(_objectSpread2({}, physicsOptions), props), {}, {\n      children: undefined\n    });\n  }, [physicsOptions, props]);\n  const immutablePropArray = immutableRigidBodyOptions.flatMap(key => {\n    return Array.isArray(mergedOptions[key]) ? [...mergedOptions[key]] : mergedOptions[key];\n  });\n  const childColliderProps = useChildColliderProps(objectRef, mergedOptions);\n\n  // Provide a way to eagerly create rigidbody\n  const getRigidBody = useImperativeInstance(() => {\n    const desc = rigidBodyDescFromOptions(mergedOptions);\n    const rigidBody = world.createRigidBody(desc);\n    if (typeof ref === \"function\") {\n      ref(rigidBody);\n    }\n    rigidBodyRef.current = rigidBody;\n    return rigidBody;\n  }, rigidBody => {\n    if (world.getRigidBody(rigidBody.handle)) {\n      world.removeRigidBody(rigidBody);\n    }\n  }, immutablePropArray);\n\n  // Only provide a object state after the ref has been set\n  useEffect(() => {\n    const rigidBody = getRigidBody();\n    const state = createRigidBodyState({\n      rigidBody,\n      object: objectRef.current\n    });\n    rigidBodyStates.set(rigidBody.handle, props.transformState ? props.transformState(state) : state);\n    return () => {\n      rigidBodyStates.delete(rigidBody.handle);\n    };\n  }, [getRigidBody]);\n  useUpdateRigidBodyOptions(getRigidBody, mergedOptions, rigidBodyStates);\n  useRigidBodyEvents(getRigidBody, mergedOptions, rigidBodyEvents);\n  const contextValue = useMemo(() => {\n    return {\n      ref: objectRef,\n      getRigidBody: getRigidBody,\n      options: mergedOptions\n    };\n  }, [getRigidBody]);\n  return /*#__PURE__*/React.createElement(RigidBodyContext.Provider, {\n    value: contextValue\n  }, /*#__PURE__*/React.createElement(\"object3D\", _extends({\n    ref: objectRef\n  }, objectProps, {\n    position: position,\n    rotation: rotation,\n    quaternion: quaternion,\n    scale: scale\n  }), children, childColliderProps.map((colliderProps, index) => /*#__PURE__*/React.createElement(AnyCollider, _extends({\n    key: index\n  }, colliderProps)))));\n});\nRigidBody.displayName = \"RigidBody\";\n\n/**\n * A mesh collider is a collider that is automatically generated from the geometry of the children.\n * @category Colliders\n */\nconst MeshCollider = /*#__PURE__*/memo(props => {\n  const {\n    children,\n    type\n  } = props;\n  const {\n    physicsOptions\n  } = useRapier();\n  const object = useRef(null);\n  const {\n    options\n  } = useRigidBodyContext();\n  const mergedOptions = useMemo(() => {\n    return _objectSpread2(_objectSpread2(_objectSpread2({}, physicsOptions), options), {}, {\n      children: undefined,\n      colliders: type\n    });\n  }, [physicsOptions, options]);\n  const childColliderProps = useChildColliderProps(object, mergedOptions, false);\n  return /*#__PURE__*/React.createElement(\"object3D\", {\n    ref: object,\n    userData: {\n      r3RapierType: \"MeshCollider\"\n    }\n  }, children, childColliderProps.map((colliderProps, index) => /*#__PURE__*/React.createElement(AnyCollider, _extends({\n    key: index\n  }, colliderProps))));\n});\nMeshCollider.displayName = \"MeshCollider\";\n\nconst _excluded = [\"ref\"],\n  _excluded2 = [\"children\", \"instances\", \"colliderNodes\", \"position\", \"rotation\", \"quaternion\", \"scale\"];\nconst InstancedRigidBodies = /*#__PURE__*/memo(_ref => {\n  let {\n      ref\n    } = _ref,\n    props = _objectWithoutProperties(_ref, _excluded);\n  const rigidBodiesRef = useForwardedRef(ref, []);\n  const objectRef = useRef(null);\n  const instanceWrapperRef = useRef(null);\n  const {\n      // instanced props\n      children,\n      instances,\n      colliderNodes = [],\n      // wrapper object props\n      position,\n      rotation,\n      quaternion,\n      scale\n\n      // rigid body specific props, and r3f-object props\n    } = props,\n    rigidBodyProps = _objectWithoutProperties(props, _excluded2);\n  const childColliderProps = useChildColliderProps(objectRef, _objectSpread2(_objectSpread2({}, props), {}, {\n    children: undefined\n  }));\n  const getInstancedMesh = () => {\n    const firstChild = instanceWrapperRef.current.children[0];\n    if (firstChild && \"isInstancedMesh\" in firstChild) {\n      return firstChild;\n    }\n    return undefined;\n  };\n  useEffect(() => {\n    const instancedMesh = getInstancedMesh();\n    if (instancedMesh) {\n      instancedMesh.instanceMatrix.setUsage(DynamicDrawUsage);\n    } else {\n      console.warn(\"InstancedRigidBodies expects exactly one child, which must be an InstancedMesh\");\n    }\n  }, []);\n\n  // Update the RigidBodyStates whenever the instances change\n  const applyInstancedState = (state, index) => {\n    const instancedMesh = getInstancedMesh();\n    if (instancedMesh) {\n      return _objectSpread2(_objectSpread2({}, state), {}, {\n        getMatrix: matrix => {\n          instancedMesh.getMatrixAt(index, matrix);\n          return matrix;\n        },\n        setMatrix: matrix => {\n          instancedMesh.setMatrixAt(index, matrix);\n          instancedMesh.instanceMatrix.needsUpdate = true;\n        },\n        meshType: \"instancedMesh\"\n      });\n    }\n    return state;\n  };\n  return /*#__PURE__*/React.createElement(\"object3D\", _extends({\n    ref: objectRef\n  }, rigidBodyProps, {\n    position: position,\n    rotation: rotation,\n    quaternion: quaternion,\n    scale: scale\n  }), /*#__PURE__*/React.createElement(\"object3D\", {\n    ref: instanceWrapperRef\n  }, children), instances === null || instances === void 0 ? void 0 : instances.map((instance, index) => /*#__PURE__*/React.createElement(RigidBody, _extends({}, rigidBodyProps, instance, {\n    ref: body => {\n      rigidBodiesRef.current[index] = body;\n    },\n    transformState: state => applyInstancedState(state, index)\n  }), /*#__PURE__*/React.createElement(React.Fragment, null, colliderNodes.map((node, index) => /*#__PURE__*/React.createElement(Fragment, {\n    key: index\n  }, node)), childColliderProps.map((colliderProps, colliderIndex) => /*#__PURE__*/React.createElement(AnyCollider, _extends({\n    key: colliderIndex\n  }, colliderProps)))))));\n});\nInstancedRigidBodies.displayName = \"InstancedRigidBodies\";\n\n/**\n * @internal\n */\nconst useImpulseJoint = (body1, body2, params) => {\n  const {\n    world\n  } = useRapier();\n  const jointRef = useRef(undefined);\n  useImperativeInstance(() => {\n    if (body1.current && body2.current) {\n      const newJoint = world.createImpulseJoint(params, body1.current, body2.current, true);\n      jointRef.current = newJoint;\n      return newJoint;\n    }\n  }, joint => {\n    if (joint) {\n      jointRef.current = undefined;\n      if (world.getImpulseJoint(joint.handle)) {\n        world.removeImpulseJoint(joint, true);\n      }\n    }\n  }, []);\n  return jointRef;\n};\n\n/**\n * A fixed joint ensures that two rigid-bodies don't move relative to each other.\n * Fixed joints are characterized by one local frame (represented by an isometry) on each rigid-body.\n * The fixed-joint makes these frames coincide in world-space.\n *\n * @category Hooks - Joints\n */\nconst useFixedJoint = (body1, body2, [body1Anchor, body1LocalFrame, body2Anchor, body2LocalFrame]) => {\n  const {\n    rapier\n  } = useRapier();\n  return useImpulseJoint(body1, body2, rapier.JointData.fixed(vector3ToRapierVector(body1Anchor), quaternionToRapierQuaternion(body1LocalFrame), vector3ToRapierVector(body2Anchor), quaternionToRapierQuaternion(body2LocalFrame)));\n};\n\n/**\n * The spherical joint ensures that two points on the local-spaces of two rigid-bodies always coincide (it prevents any relative\n * translational motion at this points). This is typically used to simulate ragdolls arms, pendulums, etc.\n * They are characterized by one local anchor on each rigid-body. Each anchor represents the location of the\n * points that need to coincide on the local-space of each rigid-body.\n *\n * @category Hooks - Joints\n */\nconst useSphericalJoint = (body1, body2, [body1Anchor, body2Anchor]) => {\n  const {\n    rapier\n  } = useRapier();\n  return useImpulseJoint(body1, body2, rapier.JointData.spherical(vector3ToRapierVector(body1Anchor), vector3ToRapierVector(body2Anchor)));\n};\n\n/**\n * The revolute joint prevents any relative movement between two rigid-bodies, except for relative\n * rotations along one axis. This is typically used to simulate wheels, fans, etc.\n * They are characterized by one local anchor as well as one local axis on each rigid-body.\n *\n * @category Hooks - Joints\n */\nconst useRevoluteJoint = (body1, body2, [body1Anchor, body2Anchor, axis, limits]) => {\n  const {\n    rapier\n  } = useRapier();\n  const params = rapier.JointData.revolute(vector3ToRapierVector(body1Anchor), vector3ToRapierVector(body2Anchor), vector3ToRapierVector(axis));\n  if (limits) {\n    params.limitsEnabled = true;\n    params.limits = limits;\n  }\n  return useImpulseJoint(body1, body2, params);\n};\n\n/**\n * The prismatic joint prevents any relative movement between two rigid-bodies, except for relative translations along one axis.\n * It is characterized by one local anchor as well as one local axis on each rigid-body. In 3D, an optional\n * local tangent axis can be specified for each rigid-body.\n *\n * @category Hooks - Joints\n */\nconst usePrismaticJoint = (body1, body2, [body1Anchor, body2Anchor, axis, limits]) => {\n  const {\n    rapier\n  } = useRapier();\n  const params = rapier.JointData.prismatic(vector3ToRapierVector(body1Anchor), vector3ToRapierVector(body2Anchor), vector3ToRapierVector(axis));\n  if (limits) {\n    params.limitsEnabled = true;\n    params.limits = limits;\n  }\n  return useImpulseJoint(body1, body2, params);\n};\n\n/**\n * The rope joint limits the max distance between two bodies.\n * @category Hooks - Joints\n */\nconst useRopeJoint = (body1, body2, [body1Anchor, body2Anchor, length]) => {\n  const {\n    rapier\n  } = useRapier();\n  const vBody1Anchor = vector3ToRapierVector(body1Anchor);\n  const vBody2Anchor = vector3ToRapierVector(body2Anchor);\n  const params = rapier.JointData.rope(length, vBody1Anchor, vBody2Anchor);\n  return useImpulseJoint(body1, body2, params);\n};\n\n/**\n * The spring joint applies a force proportional to the distance between two objects.\n * @category Hooks - Joints\n */\nconst useSpringJoint = (body1, body2, [body1Anchor, body2Anchor, restLength, stiffness, damping]) => {\n  const {\n    rapier\n  } = useRapier();\n  const vBody1Anchor = vector3ToRapierVector(body1Anchor);\n  const vBody2Anchor = vector3ToRapierVector(body2Anchor);\n  const params = rapier.JointData.spring(restLength, stiffness, damping, vBody1Anchor, vBody2Anchor);\n  return useImpulseJoint(body1, body2, params);\n};\n\n/**\n * Calculates an InteractionGroup bitmask for use in the `collisionGroups` or `solverGroups`\n * properties of RigidBody or Collider components. The first argument represents a list of\n * groups the entity is in (expressed as numbers from 0 to 15). The second argument is a list\n * of groups that will be filtered against. When it is omitted, all groups are filtered against.\n *\n * @example\n * A RigidBody that is member of group 0 and will collide with everything from groups 0 and 1:\n *\n * ```tsx\n * <RigidBody collisionGroups={interactionGroups([0], [0, 1])} />\n * ```\n *\n * A RigidBody that is member of groups 0 and 1 and will collide with everything else:\n *\n * ```tsx\n * <RigidBody collisionGroups={interactionGroups([0, 1])} />\n * ```\n *\n * A RigidBody that is member of groups 0 and 1 and will not collide with anything:\n *\n * ```tsx\n * <RigidBody collisionGroups={interactionGroups([0, 1], [])} />\n * ```\n *\n * Please note that Rapier needs interaction filters to evaluate to true between _both_ colliding\n * entities for collision events to trigger.\n *\n * @param memberships Groups the collider is a member of. (Values can range from 0 to 15.)\n * @param filters Groups the interaction group should filter against. (Values can range from 0 to 15.)\n * @returns An InteractionGroup bitmask.\n */\nconst interactionGroups = (memberships, filters) => (bitmask(memberships) << 16) + (filters !== undefined ? bitmask(filters) : 0b1111111111111111);\nconst bitmask = groups => [groups].flat().reduce((acc, layer) => acc | 1 << layer, 0);\n\nexport { AnyCollider, BallCollider, CapsuleCollider, ConeCollider, ConvexHullCollider, CuboidCollider, CylinderCollider, HeightfieldCollider, InstancedRigidBodies, MeshCollider, Physics, RigidBody, RoundConeCollider, RoundCuboidCollider, RoundCylinderCollider, TrimeshCollider, euler, interactionGroups, quat, useAfterPhysicsStep, useBeforePhysicsStep, useFixedJoint, useImpulseJoint, usePrismaticJoint, useRapier, useRevoluteJoint, useRopeJoint, useSphericalJoint, useSpringJoint, vec3 };\n"],"mappings":"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"}